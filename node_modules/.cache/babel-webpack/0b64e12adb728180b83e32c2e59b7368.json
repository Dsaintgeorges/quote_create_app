{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar os = require('os');\n\nvar helper = require('./helper');\n\nvar spawn = require('child_process').spawn;\n\nvar params = require('./params');\n\nvar debug = require('debug')('carbone:converter');\n\nvar which = require('which');\n\nvar pythonFile = path.join(__dirname, 'converter.py');\n/* Factories object */\n\nvar conversionFactory = {};\n/* An active factory is a factory which is starting (but not started completely), running or stopping (but not stopped completely) */\n\nvar activeFactories = [];\n/* Every conversion is placed in this job queue */\n\nvar jobQueue = [];\n/* If true, a factory will restart automatically */\n\nvar isAutoRestartActive = true;\nvar isLibreOfficeFound = false;\nvar converterOptions = {\n  /* Python path */\n  pythonExecPath: 'python',\n\n  /* Libre Office executable path */\n  sofficeExecPath: 'soffice',\n\n  /* Delay before killing the other process (either LibreOffice or Python) when one of them died */\n  delayBeforeKill: 500\n};\n/* get the total memory available on the system (unit: MB) */\n\nconst totalMemoryAvailableMB = os.totalmem() / 1024 / 1024;\nvar pythonErrors = {\n  1: 'Global error',\n  100: 'Existing office server not found',\n  400: 'Could not open document',\n  401: 'Could not convert document'\n};\nvar converter = {\n  /**\n   * Initialize the converter.\n   * @param {Object}   options : same options as carbone's options\n   * @param {function} callback(factory): called when all factories are ready. if startFactory is true, the first parameter will contain the object descriptor of all factories\n   */\n  init: function (options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n    } else {\n      for (var attr in options) {\n        if (params[attr] !== undefined) {\n          params[attr] = options[attr];\n        } else {\n          throw Error('Undefined options :' + attr);\n        }\n      }\n    } // restart Factory automatically if it crashes.\n\n\n    isAutoRestartActive = true; // if we must start all factory now\n\n    if (params.startFactory === true) {\n      // and if the maximum of factories is not reached\n      if (activeFactories.length < params.factories) {\n        var _nbFactoriesStarting = 0;\n\n        for (var i = 0; i < params.factories; i++) {\n          _nbFactoriesStarting++;\n          addConversionFactory(function () {\n            // here all factories are ready\n            _nbFactoriesStarting--;\n\n            if (_nbFactoriesStarting === 0 && callback) {\n              callback(conversionFactory);\n            }\n          });\n        }\n      }\n    } else {\n      // else, start LibreOffice when needed\n      if (callback) {\n        callback();\n      }\n    }\n  },\n\n  /**\n   * Kill all LibreOffice + Python threads\n   * When this method is called, we must call init() to re-initialize the converter\n   *\n   * @param {function} callback : when everything is off\n   */\n  exit: function (callback) {\n    isAutoRestartActive = false;\n    jobQueue = [];\n\n    for (var i in conversionFactory) {\n      var _factory = conversionFactory[i]; // if a factory is running\n\n      if (_factory && (_factory.pythonThread !== null || _factory.officeThread !== null)) {\n        clearTimeout(_factory.timeoutId);\n        _factory.exitCallback = factoryExitFn; // kill Python thread first.\n\n        if (_factory.pythonThread !== null) {\n          _factory.pythonThread.kill();\n        }\n\n        if (_factory.officeThread !== null) {\n          _factory.officeThread.kill();\n\n          helper.rmDirRecursive(_factory.userCachePath);\n        }\n      }\n    } // if all factories are already off\n\n\n    if (activeFactories.length === 0) {\n      factoryExitFn();\n    }\n\n    function factoryExitFn() {\n      if (activeFactories.length === 0) {\n        conversionFactory = {};\n        debug('exit!');\n\n        if (callback !== undefined) {\n          callback();\n        }\n      }\n    }\n  },\n\n  /**\n   * Convert a document\n   *\n   * @param {string} inputFile : absolute path to the source document\n   * @param {string} outputType : destination type of format.js (ex. writer_pdf_Export for PDF)\n   * @param {string} formatOptions : options string passed to convert\n   * @param {string} outputFile : outputFile to generate\n   * @param {function} callback(err, outputFile)\n   */\n  convertFile: function (inputFile, outputType, formatOptions, outputFile, callback) {\n    if (isLibreOfficeFound === false) {\n      return callback('Cannot find LibreOffice. Document conversion cannot be used');\n    }\n\n    var _job = {\n      inputFilePath: inputFile,\n      outputFilePath: outputFile,\n      outputFormat: outputType,\n      formatOptions: formatOptions || '',\n      callback: callback,\n      nbAttempt: 0,\n      error: null\n    };\n    jobQueue.push(_job);\n    executeQueue();\n  },\n\n  /**\n   * Do we need to restart LibreOffice?\n   *\n   * Temporal fix for memory leaks of LibreOffice 6+\n   *\n   * @param  {Objecct} params\n   * @param  {Integer} availableMemory system available memory\n   * @param  {Integer} nbReports       nb reborts computed by one factory\n   * @return {Boolean}                 true if LibreOffice must be restarted, false otherwise\n   */\n  shouldTheFactoryBeRestarted: function (params, availableMemory, nbReports) {\n    const _percentageFactoryMemoryLoaded = nbReports * params.factoryMemoryFileSize * 100 / availableMemory;\n\n    if (_percentageFactoryMemoryLoaded < params.factoryMemoryThreshold || params.factoryMemoryThreshold === 0) {\n      return false;\n    }\n\n    return true;\n  }\n};\n/** ***************************************************************************************************************/\n\n/* Private methods */\n\n/** ***************************************************************************************************************/\n\n/**\n * Add a LibreOffice + Python factory (= 2 threads)\n * @param {function} callback : function() called when the factory is ready to convert documents.\n */\n\nfunction addConversionFactory(callback) {\n  // find a free factory\n  var _prevFactory = {};\n\n  var _startListenerID = -1;\n\n  for (var i = 0; i < params.factories; i++) {\n    _prevFactory = conversionFactory[i];\n\n    if (_prevFactory === undefined) {\n      _startListenerID = i;\n      break;\n    } else if (_prevFactory.pythonThread === null && _prevFactory.officeThread === null) {\n      _startListenerID = i;\n      break;\n    }\n  } // maximum of factories reached\n\n\n  if (_startListenerID === -1) {\n    return callback();\n  }\n\n  var _uniqueName = helper.getUID(); // generate a unique path to a fake user profile. We cannot start multiple instances of LibreOffice if it uses the same user cache\n\n\n  var _userCachePath = path.join(params.tempPath, '_office_' + _uniqueName);\n\n  if (_prevFactory && _prevFactory.userCachePath !== undefined) {\n    // re-use previous directory if possible (faster restart)\n    _userCachePath = _prevFactory.userCachePath;\n  } // generate a URL in LibreOffice's format so that it's portable across OSes:\n  // see: https://wiki.openoffice.org/wiki/URL_Basics\n\n\n  var _userCacheURL = convertToURL(_userCachePath); // generate a unique pipe name\n\n\n  var _pipeName = params.pipeNamePrefix + '_' + _uniqueName;\n\n  var _connectionString = 'pipe,name=' + _pipeName + ';urp;StarOffice.ComponentContext';\n\n  var _officeParams = ['--headless', '--invisible', '--nocrashreport', '--nodefault', '--nologo', '--nofirststartwizard', '--norestore', '--quickstart', '--nolockcheck', '--accept=' + _connectionString, '-env:UserInstallation=' + _userCacheURL]; // save unique name\n\n  activeFactories.push(_pipeName);\n\n  var _officeThread = spawn(converterOptions.sofficeExecPath, _officeParams);\n\n  _officeThread.on('close', generateOnExitCallback(_startListenerID, false, _pipeName));\n\n  var _pythonThread = spawn(converterOptions.pythonExecPath, [pythonFile, '--pipe', _pipeName]);\n\n  _pythonThread.on('close', generateOnExitCallback(_startListenerID, true, _pipeName));\n\n  _pythonThread.stdout.on('data', generateOnDataCallback(_startListenerID));\n\n  _pythonThread.stderr.on('data', function (err) {\n    debug('python stderr :', err.toString());\n  });\n\n  if (_officeThread !== null && _pythonThread !== null) {\n    var _factory = {\n      mode: 'pipe',\n      pipeName: _pipeName,\n      userCachePath: _userCachePath,\n      pid: _officeThread.pid,\n      officeThread: _officeThread,\n      pythonThread: _pythonThread,\n      isReady: false,\n      isConverting: false,\n      readyCallback: callback,\n      nbrReports: 0,\n      timeoutId: null\n    };\n    conversionFactory[_startListenerID] = _factory;\n  } else {\n    throw new Error('Carbone: Cannot start LibreOffice or Python Thread');\n  }\n}\n/**\n * Kill one LibreOffice factory\n *\n * @param  {Object} factory\n */\n\n\nfunction killFactory(factory) {\n  if (factory.isReady === false) {\n    return;\n  }\n\n  factory.isReady = false;\n  factory.isConverting = false;\n  factory.nbrReports = 0;\n  clearTimeout(factory.timeoutId);\n\n  if (factory.officeThread !== null) {\n    factory.officeThread.kill();\n  } else if (factory.pythonThread !== null) {\n    factory.pythonThread.kill();\n  }\n}\n/**\n * Generate a callback which is used to handle thread error and exit\n * @param  {Integer} factoryID         factoryID\n * @param  {Boolean} isPythonProcess   true if the callback is used by the Python thread, false if it used by the Office Thread\n * @param  {String}  factoryUniqueName factory unique name (equals pipeName)\n * @return {Function}                  function(error)\n */\n\n\nfunction generateOnExitCallback(factoryID, isPythonProcess, factoryUniqueName) {\n  return function (error) {\n    var _processName = '';\n    var _otherThreadToKill = null; // get factory object\n\n    var _factory = conversionFactory[factoryID];\n\n    if (!_factory) {\n      throw new Error('Carbone: Process crashed but the factory is unknown!');\n    } // the factory cannot receive jobs anymore\n\n\n    _factory.isReady = false;\n    _factory.isConverting = false;\n    clearTimeout(_factory.timeoutId); // if the Python process died...\n\n    if (isPythonProcess === true) {\n      _processName = 'Python';\n      _factory.pythonThread = null;\n      _otherThreadToKill = _factory.officeThread;\n    } else {\n      _processName = 'Office';\n      _factory.officeThread = null;\n      _otherThreadToKill = _factory.pythonThread;\n    }\n\n    debug('process ' + _processName + ' of factory ' + factoryID + ' died ' + error); // if both processes Python and Office are off...\n\n    if (_factory.pythonThread === null && _factory.officeThread === null) {\n      debug('factory ' + factoryID + ' is completely off'); // remove factory from activeFactories to avoid infinite loop\n\n      activeFactories.splice(activeFactories.indexOf(factoryUniqueName), 1);\n      whenFactoryIsCompletelyOff(_factory);\n    } else {\n      _otherThreadToKill.kill('SIGKILL');\n    }\n  };\n}\n/**\n * Manage factory restart ot shutdown when a factory is completly off\n * @param  {Object} factory factory description\n */\n\n\nfunction whenFactoryIsCompletelyOff(factory) {\n  // if Carbone is not shutting down\n  if (isAutoRestartActive === true) {\n    if (factory.currentJob) {\n      // if there is an error while converting a document, let's try another time\n      factory.currentJob.error = new Error('Could not convert the document');\n    }\n\n    onCurrentJobEnd(factory); // avoid restarting too early\n\n    setTimeout(function () {\n      addConversionFactory(executeQueue);\n    }, 50);\n  } // else if Carbone is shutting down and there is an exitCallback\n  else {\n    // TODO delete async\n    // delete office files synchronously (we do not care because Carbone is shutting down) when office is dead\n    helper.rmDirRecursive(factory.userCachePath);\n\n    if (factory.exitCallback) {\n      factory.exitCallback();\n      factory.exitCallback = null;\n    }\n  }\n}\n/**\n * Generate a callback which handle communication with the Python thread\n * @param  {Integer} factoryID factoryID\n * @return {Function}          function(data)\n */\n\n\nfunction generateOnDataCallback(factoryID) {\n  return function (data) {\n    var _factory = conversionFactory[factoryID];\n    data = data.toString(); // Ready to receive document conversion\n\n    if (data === '204') {\n      debug('factory ' + factoryID + ' ready');\n      _factory.isReady = true;\n\n      if (_factory.readyCallback) {\n        _factory.readyCallback();\n      }\n\n      return executeQueue();\n    } // Document converted with or without errors\n\n\n    if (_factory.currentJob) {\n      _factory.currentJob.error = pythonErrors[data] !== undefined ? new Error(pythonErrors[data]) : null;\n    }\n\n    onCurrentJobEnd(_factory);\n  };\n}\n/**\n * Called when the job is finished\n *\n * @param  {Object} factory factory object\n */\n\n\nfunction onCurrentJobEnd(factory) {\n  var _job = factory.currentJob;\n  factory.currentJob = null;\n  factory.isConverting = false;\n  clearTimeout(factory.timeoutId);\n\n  if (_job && _job.callback instanceof Function) {\n    // save the number of report converted to check the memory level of the LO process\n    // if it reach a threshold, the LO process is killed\n    if (converter.shouldTheFactoryBeRestarted(params, totalMemoryAvailableMB, ++factory.nbrReports) === true) {\n      killFactory(factory);\n    }\n\n    _job.callback(_job.error, _job.outputFilePath);\n  }\n\n  executeQueue();\n}\n/**\n * Execute the queue of conversion.\n * It will auto executes itself until the queue is empty\n */\n\n\nfunction executeQueue() {\n  if (jobQueue.length === 0) {\n    return;\n  } // if there is no active factories, start them\n\n\n  if (activeFactories.length < params.factories) {\n    addConversionFactory(executeQueue);\n    return;\n  }\n\n  for (var i in conversionFactory) {\n    if (jobQueue.length > 0) {\n      var _factory = conversionFactory[i];\n\n      if (_factory.isReady === true && _factory.isConverting === false) {\n        var _job = jobQueue.shift();\n\n        sendToFactory(_factory, _job);\n      }\n    }\n  }\n}\n/**\n * Send the document to the Factory\n *\n * @param {object} factory : LibreOffice + Python factory to send to\n * @param {object} job : job description (file to convert, callback to call when finished, ...)\n */\n\n\nfunction sendToFactory(factory, job) {\n  factory.isConverting = true;\n  factory.currentJob = job;\n  factory.pythonThread.stdin.write('--format=\"' + job.outputFormat + '\" --input=\"' + job.inputFilePath + '\" --output=\"' + job.outputFilePath + '\" --formatOptions=\"' + job.formatOptions + '\"\\n'); // keep the number of attempts to convert this file\n\n  job.nbAttempt++; // Timeout to kill long conversions\n\n  if (params.converterFactoryTimeout > 0) {\n    clearTimeout(factory.timeoutId); // by security\n\n    factory.timeoutId = setTimeout(function () {\n      job.nbAttempt = params.attempts; // do not retry\n\n      job.error = new Error('Document conversion timeout reached (' + params.converterFactoryTimeout + ' ms)');\n      killFactory(factory);\n      onCurrentJobEnd(factory);\n    }, params.converterFactoryTimeout);\n  }\n}\n/**\n * Error for path\n *\n * @param {[type]} message [description]\n */\n\n\nfunction PathError(message) {\n  this.name = 'PathError';\n  this.code = 'PathError';\n  this.message = message || 'Failed to convert path';\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, PathError);\n  }\n}\n\nPathError.prototype = new Error();\n/**\n * Convert an absolute path to an absolute URL understood by LibreOffice and\n *  OpenOffice. This is necessary because LO/OO use a cross-platform path format\n *  that does not match paths understood natively by OSes.\n * If the input is already a URL, it is returned as-is.\n *\n * @param {string} inputPath - An absolute path to convert to a URL.\n * @returns {string} A string suitable for use with LibreOffice as an absolute file path URL.\n */\n\nfunction convertToURL(inputPath) {\n  // Guard clause: if it already looks like a URL, keep it that way.\n  if (inputPath.slice(0, 8) === 'file:///') {\n    return inputPath;\n  }\n\n  if (!path.isAbsolute(inputPath)) {\n    throw new PathError('Paths to convert must be absolute');\n  } // Split into parts so that we can join into a URL:\n\n\n  var _normalizedPath = path.normalize(inputPath); // (Use both delimiters blindly - we're aiming for maximum compatibility)\n\n\n  var _pathComponents = _normalizedPath.split(/[\\\\/]/); // Make sure there is no leading empty element, since we always add a leading \"/\" anyway.\n\n\n  if (_pathComponents[0] === '') {\n    _pathComponents.shift();\n  }\n\n  var outputURL = 'file:///' + _pathComponents.join('/');\n\n  return outputURL;\n}\n/**\n * Detect If LibreOffice and python are available at startup\n */\n\n\nfunction detectLibreOffice(additionalPaths) {\n  function _findBundledPython(sofficePath, pythonName) {\n    if (!sofficePath) {\n      return null;\n    } // Try finding a Python binary shipped alongside the soffice binary,\n    //  either in its actual directory, or - if it's a symbolic link -\n    //  in the directory it points to.\n\n\n    var _sofficeActualDirectory;\n\n    var _symlinkDestination;\n\n    try {\n      _symlinkDestination = path.resolve(path.dirname(sofficePath), fs.readlinkSync(sofficePath)); // Assume symbolic link, will throw in case it's not:\n\n      _sofficeActualDirectory = path.dirname(_symlinkDestination);\n    } catch (errorToIgnore) {\n      // Not a symlink.\n      _sofficeActualDirectory = path.dirname(sofficePath);\n    } // Check for the Python binary in the actual soffice path:\n\n\n    try {\n      return which.sync(pythonName, {\n        path: _sofficeActualDirectory\n      });\n    } catch (errorToIgnore) {\n      // No bundled Python found.\n      return null;\n    }\n  }\n\n  function _findBinaries(paths, pythonName, sofficeName) {\n    var _whichPython;\n\n    var _whichSoffice; // Look for the soffice binary - first in the well-known paths, then in\n    //  the system PATH. On Linux, this prioritizes \"upstream\" (TDF) packages\n    //  over distro-provided ones from the OS' repository.\n\n\n    _whichSoffice = which.sync(sofficeName, {\n      path: paths.join(':'),\n      nothrow: true\n    }) || which.sync(sofficeName, {\n      nothrow: true\n    }) || null; // Check for a Python binary bundled with soffice, fall back to system-wide:\n    // This is a bit more complex, since we deal with some corner cases.\n    // 1. Hopefully use the python from the original soffice package, same dir\n    //  (this might fail on Mac if python is not in MacOS/, but in Resources/).\n    // 1a. Corner case: on Linux, if soffice was in /usr/bin/soffice and NOT\n    //  a symlink, then we would hit /usr/bin/python, which is probably python2.\n    //  This is why we try with python3 first, to defend against this.\n    // 2. Try finding it in any of the well-known paths - this might result in\n    //  using Python from *another install* of LibreOffice, but it should be ok.\n    //  This is only attempted if the paths exist on this system to avoid\n    //  a fallback to system PATH that \"which\" does when passed an empty string.\n    // 3. Fall back to system python (hopefully named python3).\n\n    _whichPython = _findBundledPython(_whichSoffice, 'python3') || _findBundledPython(_whichSoffice, 'python') || paths.length > 0 && which.sync('python3', {\n      path: paths.join(':'),\n      nothrow: true\n    }) || paths.length > 0 && which.sync('python', {\n      path: paths.join(':'),\n      nothrow: true\n    }) || which.sync('python3', {\n      nothrow: true\n    }) || which.sync('python', {\n      nothrow: true\n    }) || null;\n    return {\n      soffice: _whichSoffice,\n      python: _whichPython\n    };\n  }\n\n  function _listProgramDirectories(basePath, pattern) {\n    try {\n      return fs.readdirSync(basePath).filter(function _isLibreOfficeDirectory(dirname) {\n        return pattern.test(dirname);\n      }).map(function _buildFullProgramPath(dirname) {\n        return path.join(basePath, dirname, 'program');\n      });\n    } catch (errorToIgnore) {\n      return [];\n    }\n  }\n\n  var _pathsToCheck = additionalPaths || []; // overridable file names to look for in the checked paths:\n\n\n  var _pythonName = 'python';\n  var _sofficeName = 'soffice';\n  var _linuxDirnamePattern = /^libreoffice\\d+\\.\\d+$/;\n  var _windowsDirnamePattern = /^LibreOffice( \\d+(?:\\.\\d+)*?)?$/i;\n\n  if (process.platform === 'darwin') {\n    _pathsToCheck = _pathsToCheck.concat([// It is better to use the python bundled with LibreOffice:\n    '/Applications/LibreOffice.app/Contents/MacOS', '/Applications/LibreOffice.app/Contents/Resources']);\n  } else if (process.platform === 'linux') {\n    // The Document Foundation packages (.debs, at least) install to /opt,\n    //  into a directory named after the contained LibreOffice version.\n    // Add any existing directories that match this to the list.\n    _pathsToCheck = _pathsToCheck.concat(_listProgramDirectories('/opt', _linuxDirnamePattern));\n  } else if (process.platform === 'win32') {\n    _pathsToCheck = _pathsToCheck.concat(_listProgramDirectories('C:\\\\Program Files', _windowsDirnamePattern)).concat(_listProgramDirectories('C:\\\\Program Files (x86)', _windowsDirnamePattern));\n    _pythonName = 'python.exe';\n  } else {\n    debug('your platform \"%s\" is not supported yet', process.platform);\n  } // Common logic for all OSes: perform the search and save results as options:\n\n\n  var _foundPaths = _findBinaries(_pathsToCheck, _pythonName, _sofficeName);\n\n  if (_foundPaths.soffice) {\n    debug('LibreOffice found: soffice at %s, python at %s', _foundPaths.soffice, _foundPaths.python);\n    isLibreOfficeFound = true;\n    converterOptions.pythonExecPath = _foundPaths.python;\n    converterOptions.sofficeExecPath = _foundPaths.soffice;\n  }\n\n  if (isLibreOfficeFound === false) {\n    debug('cannot find LibreOffice. Document conversion cannot be used');\n  }\n}\n\ndetectLibreOffice();\nprocess.on('exit', function () {\n  converter.exit();\n});\nmodule.exports = converter;","map":{"version":3,"sources":["/Users/doryan/Documents/Project/quoteCreator/node_modules/carbone/lib/converter.js"],"names":["path","require","fs","os","helper","spawn","params","debug","which","pythonFile","join","__dirname","conversionFactory","activeFactories","jobQueue","isAutoRestartActive","isLibreOfficeFound","converterOptions","pythonExecPath","sofficeExecPath","delayBeforeKill","totalMemoryAvailableMB","totalmem","pythonErrors","converter","init","options","callback","attr","undefined","Error","startFactory","length","factories","_nbFactoriesStarting","i","addConversionFactory","exit","_factory","pythonThread","officeThread","clearTimeout","timeoutId","exitCallback","factoryExitFn","kill","rmDirRecursive","userCachePath","convertFile","inputFile","outputType","formatOptions","outputFile","_job","inputFilePath","outputFilePath","outputFormat","nbAttempt","error","push","executeQueue","shouldTheFactoryBeRestarted","availableMemory","nbReports","_percentageFactoryMemoryLoaded","factoryMemoryFileSize","factoryMemoryThreshold","_prevFactory","_startListenerID","_uniqueName","getUID","_userCachePath","tempPath","_userCacheURL","convertToURL","_pipeName","pipeNamePrefix","_connectionString","_officeParams","_officeThread","on","generateOnExitCallback","_pythonThread","stdout","generateOnDataCallback","stderr","err","toString","mode","pipeName","pid","isReady","isConverting","readyCallback","nbrReports","killFactory","factory","factoryID","isPythonProcess","factoryUniqueName","_processName","_otherThreadToKill","splice","indexOf","whenFactoryIsCompletelyOff","currentJob","onCurrentJobEnd","setTimeout","data","Function","shift","sendToFactory","job","stdin","write","converterFactoryTimeout","attempts","PathError","message","name","code","captureStackTrace","prototype","inputPath","slice","isAbsolute","_normalizedPath","normalize","_pathComponents","split","outputURL","detectLibreOffice","additionalPaths","_findBundledPython","sofficePath","pythonName","_sofficeActualDirectory","_symlinkDestination","resolve","dirname","readlinkSync","errorToIgnore","sync","_findBinaries","paths","sofficeName","_whichPython","_whichSoffice","nothrow","soffice","python","_listProgramDirectories","basePath","pattern","readdirSync","filter","_isLibreOfficeDirectory","test","map","_buildFullProgramPath","_pathsToCheck","_pythonName","_sofficeName","_linuxDirnamePattern","_windowsDirnamePattern","process","platform","concat","_foundPaths","module","exports"],"mappings":"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","sourcesContent":["var path  = require('path');\nvar fs = require('fs');\nvar os = require('os');\nvar helper = require('./helper');\nvar spawn = require('child_process').spawn;\nvar params = require('./params');\nvar debug = require('debug')('carbone:converter');\nvar which = require('which');\n\nvar pythonFile = path.join(__dirname, 'converter.py');\n\n/* Factories object */\nvar conversionFactory = {};\n/* An active factory is a factory which is starting (but not started completely), running or stopping (but not stopped completely) */\nvar activeFactories = [];\n/* Every conversion is placed in this job queue */\nvar jobQueue = [];\n/* If true, a factory will restart automatically */\nvar isAutoRestartActive = true;\n\nvar isLibreOfficeFound = false;\n\nvar converterOptions = {\n  /* Python path */\n  pythonExecPath  : 'python',\n  /* Libre Office executable path */\n  sofficeExecPath : 'soffice',\n  /* Delay before killing the other process (either LibreOffice or Python) when one of them died */\n  delayBeforeKill : 500\n};\n\n/* get the total memory available on the system (unit: MB) */\nconst totalMemoryAvailableMB = os.totalmem() / 1024 / 1024;\n\n\nvar pythonErrors = {\n  1   : 'Global error',\n  100 : 'Existing office server not found',\n  400 : 'Could not open document',\n  401 : 'Could not convert document'\n};\n\n\nvar converter = {\n\n  /**\n   * Initialize the converter.\n   * @param {Object}   options : same options as carbone's options\n   * @param {function} callback(factory): called when all factories are ready. if startFactory is true, the first parameter will contain the object descriptor of all factories\n   */\n  init : function (options, callback) {\n    if (typeof(options) === 'function') {\n      callback = options;\n    }\n    else {\n      for (var attr in options) {\n        if (params[attr]!== undefined) {\n          params[attr] = options[attr];\n        }\n        else {\n          throw Error('Undefined options :' + attr);\n        }\n      }\n    }\n    // restart Factory automatically if it crashes.\n    isAutoRestartActive = true;\n\n    // if we must start all factory now\n    if (params.startFactory === true) {\n      // and if the maximum of factories is not reached\n      if (activeFactories.length < params.factories) {\n        var _nbFactoriesStarting=0;\n        for (var i = 0; i < params.factories; i++) {\n          _nbFactoriesStarting++;\n          addConversionFactory(function () {\n            // here all factories are ready\n            _nbFactoriesStarting--;\n            if (_nbFactoriesStarting === 0 && callback) {\n              callback(conversionFactory);\n            }\n          });\n        }\n      }\n    }\n    else {\n      // else, start LibreOffice when needed\n      if (callback) {\n        callback();\n      }\n    }\n  },\n\n  /**\n   * Kill all LibreOffice + Python threads\n   * When this method is called, we must call init() to re-initialize the converter\n   *\n   * @param {function} callback : when everything is off\n   */\n  exit : function (callback) {\n    isAutoRestartActive = false;\n    jobQueue = [];\n    for (var i in conversionFactory) {\n      var _factory = conversionFactory[i];\n      // if a factory is running\n      if (_factory && (_factory.pythonThread !== null || _factory.officeThread !== null)) {\n        clearTimeout(_factory.timeoutId);\n        _factory.exitCallback = factoryExitFn;\n        // kill Python thread first.\n        if (_factory.pythonThread !== null) {\n          _factory.pythonThread.kill();\n        }\n        if (_factory.officeThread !== null) {\n          _factory.officeThread.kill();\n          helper.rmDirRecursive(_factory.userCachePath);\n        }\n      }\n    }\n    // if all factories are already off\n    if (activeFactories.length === 0) {\n      factoryExitFn();\n    }\n\n    function factoryExitFn () {\n      if (activeFactories.length === 0) {\n        conversionFactory = {};\n        debug('exit!');\n        if (callback !== undefined) {\n          callback();\n        }\n      }\n    }\n  },\n\n  /**\n   * Convert a document\n   *\n   * @param {string} inputFile : absolute path to the source document\n   * @param {string} outputType : destination type of format.js (ex. writer_pdf_Export for PDF)\n   * @param {string} formatOptions : options string passed to convert\n   * @param {string} outputFile : outputFile to generate\n   * @param {function} callback(err, outputFile)\n   */\n  convertFile : function (inputFile, outputType, formatOptions, outputFile, callback) {\n\n    if (isLibreOfficeFound === false) {\n      return callback('Cannot find LibreOffice. Document conversion cannot be used');\n    }\n\n    var _job = {\n      inputFilePath  : inputFile,\n      outputFilePath : outputFile,\n      outputFormat   : outputType,\n      formatOptions  : formatOptions || '',\n      callback       : callback,\n      nbAttempt      : 0,\n      error          : null\n    };\n    jobQueue.push(_job);\n    executeQueue();\n  },\n\n  /**\n   * Do we need to restart LibreOffice?\n   *\n   * Temporal fix for memory leaks of LibreOffice 6+\n   *\n   * @param  {Objecct} params\n   * @param  {Integer} availableMemory system available memory\n   * @param  {Integer} nbReports       nb reborts computed by one factory\n   * @return {Boolean}                 true if LibreOffice must be restarted, false otherwise\n   */\n  shouldTheFactoryBeRestarted : function (params, availableMemory, nbReports) {\n    const _percentageFactoryMemoryLoaded = nbReports * params.factoryMemoryFileSize * 100 / availableMemory;\n    if (_percentageFactoryMemoryLoaded < params.factoryMemoryThreshold || params.factoryMemoryThreshold === 0) {\n      return false;\n    }\n    return true;\n  }\n\n};\n\n\n/** ***************************************************************************************************************/\n/* Private methods */\n/** ***************************************************************************************************************/\n\n\n/**\n * Add a LibreOffice + Python factory (= 2 threads)\n * @param {function} callback : function() called when the factory is ready to convert documents.\n */\nfunction addConversionFactory (callback) {\n  // find a free factory\n  var _prevFactory = {};\n  var _startListenerID = -1;\n  for (var i = 0; i < params.factories; i++) {\n    _prevFactory = conversionFactory[i];\n    if (_prevFactory === undefined) {\n      _startListenerID = i;\n      break;\n    }\n    else if (_prevFactory.pythonThread === null && _prevFactory.officeThread === null) {\n      _startListenerID = i;\n      break;\n    }\n  }\n  // maximum of factories reached\n  if (_startListenerID === -1) {\n    return callback();\n  }\n  var _uniqueName = helper.getUID();\n\n  // generate a unique path to a fake user profile. We cannot start multiple instances of LibreOffice if it uses the same user cache\n  var _userCachePath = path.join(params.tempPath, '_office_' + _uniqueName);\n  if (_prevFactory && _prevFactory.userCachePath !== undefined) {\n    // re-use previous directory if possible (faster restart)\n    _userCachePath = _prevFactory.userCachePath;\n  }\n  // generate a URL in LibreOffice's format so that it's portable across OSes:\n  // see: https://wiki.openoffice.org/wiki/URL_Basics\n  var _userCacheURL = convertToURL(_userCachePath);\n\n  // generate a unique pipe name\n  var _pipeName = params.pipeNamePrefix + '_' +_uniqueName;\n  var _connectionString = 'pipe,name=' + _pipeName + ';urp;StarOffice.ComponentContext';\n  var _officeParams = ['--headless', '--invisible', '--nocrashreport', '--nodefault', '--nologo', '--nofirststartwizard', '--norestore',\n    '--quickstart', '--nolockcheck', '--accept='+_connectionString, '-env:UserInstallation='+_userCacheURL ];\n\n  // save unique name\n  activeFactories.push(_pipeName);\n\n  var _officeThread = spawn(converterOptions.sofficeExecPath, _officeParams);\n  _officeThread.on('close', generateOnExitCallback(_startListenerID, false, _pipeName));\n\n  var _pythonThread = spawn(converterOptions.pythonExecPath, [pythonFile, '--pipe', _pipeName]);\n  _pythonThread.on('close', generateOnExitCallback(_startListenerID, true, _pipeName));\n  _pythonThread.stdout.on('data', generateOnDataCallback(_startListenerID));\n  _pythonThread.stderr.on('data', function (err) {\n    debug('python stderr :', err.toString());\n  });\n\n  if (_officeThread !== null && _pythonThread !== null) {\n    var _factory = {\n      mode          : 'pipe',\n      pipeName      : _pipeName,\n      userCachePath : _userCachePath,\n      pid           : _officeThread.pid,\n      officeThread  : _officeThread,\n      pythonThread  : _pythonThread,\n      isReady       : false,\n      isConverting  : false,\n      readyCallback : callback,\n      nbrReports    : 0,\n      timeoutId     : null\n    };\n    conversionFactory[_startListenerID] = _factory;\n  }\n  else {\n    throw new Error('Carbone: Cannot start LibreOffice or Python Thread');\n  }\n}\n\n/**\n * Kill one LibreOffice factory\n *\n * @param  {Object} factory\n */\nfunction killFactory (factory) {\n  if (factory.isReady === false) {\n    return;\n  }\n  factory.isReady      = false;\n  factory.isConverting = false;\n  factory.nbrReports   = 0;\n  clearTimeout(factory.timeoutId);\n  if (factory.officeThread !== null) {\n    factory.officeThread.kill();\n  }\n  else if (factory.pythonThread !== null) {\n    factory.pythonThread.kill();\n  }\n}\n\n/**\n * Generate a callback which is used to handle thread error and exit\n * @param  {Integer} factoryID         factoryID\n * @param  {Boolean} isPythonProcess   true if the callback is used by the Python thread, false if it used by the Office Thread\n * @param  {String}  factoryUniqueName factory unique name (equals pipeName)\n * @return {Function}                  function(error)\n */\nfunction generateOnExitCallback (factoryID, isPythonProcess, factoryUniqueName) {\n  return function (error) {\n    var _processName = '';\n    var _otherThreadToKill = null;\n\n    // get factory object\n    var _factory = conversionFactory[factoryID];\n    if (!_factory) {\n      throw new Error('Carbone: Process crashed but the factory is unknown!');\n    }\n\n    // the factory cannot receive jobs anymore\n    _factory.isReady = false;\n    _factory.isConverting = false;\n    clearTimeout(_factory.timeoutId);\n\n    // if the Python process died...\n    if (isPythonProcess === true) {\n      _processName = 'Python';\n      _factory.pythonThread = null;\n      _otherThreadToKill = _factory.officeThread;\n    }\n    else {\n      _processName = 'Office';\n      _factory.officeThread = null;\n      _otherThreadToKill = _factory.pythonThread;\n    }\n\n    debug('process '+_processName+' of factory '+factoryID+' died ' + error);\n\n    // if both processes Python and Office are off...\n    if (_factory.pythonThread === null && _factory.officeThread === null) {\n      debug('factory '+factoryID+' is completely off');\n      // remove factory from activeFactories to avoid infinite loop\n      activeFactories.splice(activeFactories.indexOf(factoryUniqueName), 1);\n      whenFactoryIsCompletelyOff(_factory);\n    }\n    else {\n      _otherThreadToKill.kill('SIGKILL');\n    }\n  };\n}\n\n\n/**\n * Manage factory restart ot shutdown when a factory is completly off\n * @param  {Object} factory factory description\n */\nfunction whenFactoryIsCompletelyOff (factory) {\n  // if Carbone is not shutting down\n  if (isAutoRestartActive === true) {\n    if (factory.currentJob) {\n      // if there is an error while converting a document, let's try another time\n      factory.currentJob.error = new Error('Could not convert the document');\n    }\n    onCurrentJobEnd(factory);\n    // avoid restarting too early\n    setTimeout(function () {\n      addConversionFactory(executeQueue);\n    },50);\n  }\n  // else if Carbone is shutting down and there is an exitCallback\n  else {\n    // TODO delete async\n    // delete office files synchronously (we do not care because Carbone is shutting down) when office is dead\n    helper.rmDirRecursive(factory.userCachePath);\n    if (factory.exitCallback) {\n      factory.exitCallback();\n      factory.exitCallback = null;\n    }\n  }\n}\n\n\n/**\n * Generate a callback which handle communication with the Python thread\n * @param  {Integer} factoryID factoryID\n * @return {Function}          function(data)\n */\nfunction generateOnDataCallback (factoryID) {\n  return function (data) {\n    var _factory = conversionFactory[factoryID];\n    data = data.toString();\n    // Ready to receive document conversion\n    if (data === '204') {\n      debug('factory '+factoryID+' ready');\n      _factory.isReady = true;\n      if (_factory.readyCallback) {\n        _factory.readyCallback();\n      }\n      return executeQueue();\n    }\n    // Document converted with or without errors\n    if (_factory.currentJob) {\n      _factory.currentJob.error = (pythonErrors[data] !== undefined) ? new Error(pythonErrors[data]) : null;\n    }\n    onCurrentJobEnd(_factory);\n  };\n}\n\n/**\n * Called when the job is finished\n *\n * @param  {Object} factory factory object\n */\nfunction onCurrentJobEnd (factory) {\n  var _job = factory.currentJob;\n  factory.currentJob = null;\n  factory.isConverting = false;\n  clearTimeout(factory.timeoutId);\n  if (_job && _job.callback instanceof Function) {\n    // save the number of report converted to check the memory level of the LO process\n    // if it reach a threshold, the LO process is killed\n    if (converter.shouldTheFactoryBeRestarted(params, totalMemoryAvailableMB, ++factory.nbrReports) === true) {\n      killFactory(factory);\n    }\n    _job.callback(_job.error, _job.outputFilePath);\n  }\n  executeQueue();\n}\n\n\n/**\n * Execute the queue of conversion.\n * It will auto executes itself until the queue is empty\n */\nfunction executeQueue () {\n  if (jobQueue.length===0) {\n    return;\n  }\n  // if there is no active factories, start them\n  if (activeFactories.length < params.factories) {\n    addConversionFactory(executeQueue);\n    return;\n  }\n  for (var i in conversionFactory) {\n    if (jobQueue.length > 0) {\n      var _factory = conversionFactory[i];\n      if (_factory.isReady === true && _factory.isConverting === false) {\n        var _job = jobQueue.shift();\n        sendToFactory(_factory, _job);\n      }\n    }\n  }\n}\n\n/**\n * Send the document to the Factory\n *\n * @param {object} factory : LibreOffice + Python factory to send to\n * @param {object} job : job description (file to convert, callback to call when finished, ...)\n */\nfunction sendToFactory (factory, job) {\n  factory.isConverting = true;\n  factory.currentJob = job;\n  factory.pythonThread.stdin.write('--format=\"'+job.outputFormat+'\" --input=\"'+job.inputFilePath+'\" --output=\"'+job.outputFilePath+'\" --formatOptions=\"'+job.formatOptions+'\"\\n');\n  // keep the number of attempts to convert this file\n  job.nbAttempt++;\n  // Timeout to kill long conversions\n  if (params.converterFactoryTimeout > 0) {\n    clearTimeout(factory.timeoutId); // by security\n    factory.timeoutId = setTimeout(function () {\n      job.nbAttempt = params.attempts; // do not retry\n      job.error = new Error('Document conversion timeout reached ('+params.converterFactoryTimeout+' ms)');\n      killFactory(factory);\n      onCurrentJobEnd(factory);\n    }, params.converterFactoryTimeout);\n  }\n}\n\n\n/**\n * Error for path\n *\n * @param {[type]} message [description]\n */\nfunction PathError (message) {\n  this.name = 'PathError';\n  this.code = 'PathError';\n  this.message = message || 'Failed to convert path';\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, PathError);\n  }\n}\nPathError.prototype = new Error();\n\n/**\n * Convert an absolute path to an absolute URL understood by LibreOffice and\n *  OpenOffice. This is necessary because LO/OO use a cross-platform path format\n *  that does not match paths understood natively by OSes.\n * If the input is already a URL, it is returned as-is.\n *\n * @param {string} inputPath - An absolute path to convert to a URL.\n * @returns {string} A string suitable for use with LibreOffice as an absolute file path URL.\n */\nfunction convertToURL (inputPath) {\n  // Guard clause: if it already looks like a URL, keep it that way.\n  if (inputPath.slice(0, 8) === 'file:///') {\n    return inputPath;\n  }\n  if (!path.isAbsolute(inputPath)) {\n    throw new PathError('Paths to convert must be absolute');\n  }\n  // Split into parts so that we can join into a URL:\n  var _normalizedPath = path.normalize(inputPath);\n  // (Use both delimiters blindly - we're aiming for maximum compatibility)\n  var _pathComponents = _normalizedPath.split(/[\\\\/]/);\n  // Make sure there is no leading empty element, since we always add a leading \"/\" anyway.\n  if (_pathComponents[0] === '') {\n    _pathComponents.shift();\n  }\n  var outputURL = 'file:///' + _pathComponents.join('/');\n  return outputURL;\n}\n\n\n/**\n * Detect If LibreOffice and python are available at startup\n */\nfunction detectLibreOffice (additionalPaths) {\n  function _findBundledPython (sofficePath, pythonName) {\n    if (!sofficePath) {\n      return null;\n    }\n    // Try finding a Python binary shipped alongside the soffice binary,\n    //  either in its actual directory, or - if it's a symbolic link -\n    //  in the directory it points to.\n    var _sofficeActualDirectory;\n    var _symlinkDestination;\n    try {\n      _symlinkDestination = path.resolve(path.dirname(sofficePath), fs.readlinkSync(sofficePath));\n      // Assume symbolic link, will throw in case it's not:\n      _sofficeActualDirectory = path.dirname(_symlinkDestination);\n    }\n    catch (errorToIgnore) {\n      // Not a symlink.\n      _sofficeActualDirectory = path.dirname(sofficePath);\n    }\n    // Check for the Python binary in the actual soffice path:\n    try {\n      return which.sync(pythonName, { path : _sofficeActualDirectory });\n    }\n    catch (errorToIgnore) {\n      // No bundled Python found.\n      return null;\n    }\n  }\n\n  function _findBinaries (paths, pythonName, sofficeName) {\n    var _whichPython;\n    var _whichSoffice;\n    // Look for the soffice binary - first in the well-known paths, then in\n    //  the system PATH. On Linux, this prioritizes \"upstream\" (TDF) packages\n    //  over distro-provided ones from the OS' repository.\n    _whichSoffice = which.sync(sofficeName, { path : paths.join(':'), nothrow : true }) || which.sync(sofficeName, { nothrow : true }) || null;\n    // Check for a Python binary bundled with soffice, fall back to system-wide:\n    // This is a bit more complex, since we deal with some corner cases.\n    // 1. Hopefully use the python from the original soffice package, same dir\n    //  (this might fail on Mac if python is not in MacOS/, but in Resources/).\n    // 1a. Corner case: on Linux, if soffice was in /usr/bin/soffice and NOT\n    //  a symlink, then we would hit /usr/bin/python, which is probably python2.\n    //  This is why we try with python3 first, to defend against this.\n    // 2. Try finding it in any of the well-known paths - this might result in\n    //  using Python from *another install* of LibreOffice, but it should be ok.\n    //  This is only attempted if the paths exist on this system to avoid\n    //  a fallback to system PATH that \"which\" does when passed an empty string.\n    // 3. Fall back to system python (hopefully named python3).\n    _whichPython = _findBundledPython(_whichSoffice, 'python3') ||\n                  _findBundledPython(_whichSoffice, 'python') ||\n                  (paths.length > 0 && which.sync('python3', { path : paths.join(':'), nothrow : true })) ||\n                  (paths.length > 0 && which.sync('python', { path : paths.join(':'), nothrow : true })) ||\n                  which.sync('python3', { nothrow : true }) ||\n                  which.sync('python', { nothrow : true }) || null;\n    return {\n      soffice : _whichSoffice,\n      python  : _whichPython\n    };\n  }\n\n  function _listProgramDirectories (basePath, pattern) {\n    try {\n      return fs.readdirSync(basePath).filter(function _isLibreOfficeDirectory (dirname) {\n        return pattern.test(dirname);\n      }).map(function _buildFullProgramPath (dirname) {\n        return path.join(basePath, dirname, 'program');\n      });\n    }\n    catch (errorToIgnore) {\n      return [];\n    }\n  }\n\n  var _pathsToCheck = additionalPaths || [];\n  // overridable file names to look for in the checked paths:\n  var _pythonName = 'python';\n  var _sofficeName = 'soffice';\n  var _linuxDirnamePattern = /^libreoffice\\d+\\.\\d+$/;\n  var _windowsDirnamePattern = /^LibreOffice( \\d+(?:\\.\\d+)*?)?$/i;\n\n  if (process.platform === 'darwin') {\n    _pathsToCheck = _pathsToCheck.concat([\n      // It is better to use the python bundled with LibreOffice:\n      '/Applications/LibreOffice.app/Contents/MacOS',\n      '/Applications/LibreOffice.app/Contents/Resources'\n    ]);\n  }\n  else if (process.platform === 'linux') {\n    // The Document Foundation packages (.debs, at least) install to /opt,\n    //  into a directory named after the contained LibreOffice version.\n    // Add any existing directories that match this to the list.\n    _pathsToCheck = _pathsToCheck.concat(_listProgramDirectories('/opt', _linuxDirnamePattern));\n  }\n  else if (process.platform === 'win32') {\n    _pathsToCheck = _pathsToCheck\n      .concat(_listProgramDirectories('C:\\\\Program Files', _windowsDirnamePattern))\n      .concat(_listProgramDirectories('C:\\\\Program Files (x86)', _windowsDirnamePattern));\n    _pythonName = 'python.exe';\n  }\n  else {\n    debug('your platform \"%s\" is not supported yet', process.platform);\n  }\n\n  // Common logic for all OSes: perform the search and save results as options:\n  var _foundPaths = _findBinaries(_pathsToCheck, _pythonName, _sofficeName);\n  if (_foundPaths.soffice) {\n    debug('LibreOffice found: soffice at %s, python at %s', _foundPaths.soffice, _foundPaths.python);\n    isLibreOfficeFound = true;\n    converterOptions.pythonExecPath = _foundPaths.python;\n    converterOptions.sofficeExecPath = _foundPaths.soffice;\n  }\n\n  if (isLibreOfficeFound === false) {\n    debug('cannot find LibreOffice. Document conversion cannot be used');\n  }\n}\n\ndetectLibreOffice();\n\nprocess.on('exit', function () {\n  converter.exit();\n});\n\nmodule.exports = converter;\n"]},"metadata":{},"sourceType":"script"}