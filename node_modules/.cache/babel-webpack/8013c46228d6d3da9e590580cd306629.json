{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar assert = require('assert');\n\nvar crypto = require('crypto');\n\nvar params = require('./params');\n\nvar exec = require('child_process').exec;\n\nvar debug = require('debug')('carbone:helper');\n\nvar sameUIDCounter = 0;\nvar prevTimestamp = 0; // Random values to pre-allocate\n\nconst randomPool = Buffer.alloc(256);\nvar randomPoolPointer = randomPool.length;\nvar helper = {\n  /**\n   * Generate a unique id\n   * @return {String} unique id\n   */\n  getUID: function () {\n    var _timestamp = Date.now();\n\n    var _uid = params.uidPrefix + '_' + _timestamp + '_' + process.pid + '_';\n\n    if (_timestamp === prevTimestamp) {\n      _uid += ++sameUIDCounter;\n    } else {\n      _uid += '0';\n      sameUIDCounter = 0;\n    }\n\n    prevTimestamp = _timestamp;\n    return _uid;\n  },\n\n  /**\n   * Generate a constant-length base64 random string without forbidden characters for filesystem\n   *\n   * [/+] are replaced by [-_]\n   *\n   * Length : 22 characters\n   * It is 5 times slower than getUID above but a lot more secure to generate public filename\n   *\n   * It uses Cryptographically Secure Pseudo-Random Number Generator, with unbiased (ie secure) tranformation\n   * Same collision probability as standard 128 bits uuid-v4\n   * Doc: https://gist.github.com/joepie91/7105003c3b26e65efcea63f3db82dfba\n   *\n   * @return {String}   The random string\n   */\n  RANDOM_STRING_LENGTH: 22,\n  getRandomString: function () {\n    if (randomPoolPointer > randomPool.length - 16) {\n      // It is alot simpler to use sync version\n      // Otherwose, we must maintain a table of callback\n      // This sync function is called 1/16 times\n      crypto.randomFillSync(randomPool);\n      randomPoolPointer = 0;\n    }\n\n    let _randomStr = randomPool.toString('base64', randomPoolPointer, randomPoolPointer += 16);\n\n    return _randomStr.slice(0, -2).replace(/\\//g, '-').replace(/\\+/g, '_');\n  },\n\n  /**\n   * Encode any string to a base64 string, safe for generating POSIX compatible filenames\n   *\n   * @param  {String}  str The string\n   * @return {String}      A safe filename\n   */\n  encodeSafeFilename: function (str) {\n    return Buffer.from(str || '').toString('base64').replace(/=/g, '').replace(/\\//g, '-').replace(/\\+/g, '_');\n  },\n\n  /**\n   * Decode a base64 safe filename to the original string\n   *\n   * @param  {String}  filename  The filename\n   * @return {String}            Return original string\n   */\n  decodeSafeFilename: function (filename) {\n    return Buffer.from((filename || '').replace(/-/g, '/').replace(/_/g, '+'), 'base64').toString('utf8');\n  },\n\n  /**\n   * Beautiful assert between two objects\n   * Be careful, it will inspect with a depth of 100\n   *\n   * @param {object} result : result\n   * @param {object} expected : expected\n   * @return {type} throw an error if the two objects are different\n   */\n  assert: function (result, expected, message) {\n    try {\n      assert.equal(JSON.stringify(result, null, 2), JSON.stringify(expected, null, 2), message);\n    } catch (e) {\n      e.showDiff = true;\n      throw e;\n    }\n  },\n\n  /**\n   * Read all files of a directory\n   *\n   * @param {string} dir : path to the directory we want to scan\n   * @param {string} extension (optional) : filter on file extension. Example: 'sql' (without the point). Can be a regex\n   * @return {object} : {'file/path/name.js':'content of the file', ...}\n   */\n  readFileDirSync: function (dir, extension) {\n    var _that = this;\n\n    var _res = {};\n\n    var _files = _that.walkDirSync(dir, extension);\n\n    for (var i = 0; i < _files.length; i++) {\n      var _filePath = _files[i];\n\n      var _code = fs.readFileSync(_filePath, 'utf8');\n\n      _res[_filePath] = _code;\n    }\n\n    return _res;\n  },\n  cleanJavascriptVariable: function (attributeName) {\n    return attributeName.replace(/[^a-zA-Z0-9$_]/g, '_');\n  },\n\n  /**\n   * Remove quotes from string\n   *\n   * @param  {Strring} str  string with or without quotes\n   * @return {String}       string without surrounding quotes\n   */\n  removeQuote: function (str) {\n    if (typeof str === 'string') {\n      return str.replace(/^ *['\"]?/, '').replace(/['\"]? *$/, '');\n    }\n\n    return str;\n  },\n\n  /**\n   * Remove a directory and all its content\n   * Be careful, this method is synchrone\n   *\n   * @param {type} dir : directory path\n   */\n  rmDirRecursive: function (dir) {\n    if (!fs.existsSync(dir)) {\n      return;\n    }\n\n    var _list = fs.readdirSync(dir);\n\n    for (var i = 0; i < _list.length; i++) {\n      var _filename = path.join(dir, _list[i]);\n\n      var _stat = fs.statSync(_filename);\n\n      if (_stat.isFile()) {\n        // if this is a file, remove it\n        fs.unlinkSync(_filename);\n      } else if (_stat.isDirectory()) {\n        // if the is a dircetory, call the function recursively\n        this.rmDirRecursive(_filename);\n      }\n    }\n\n    fs.rmdirSync(dir);\n  },\n\n  /**\n   * Remove a directory and all its content using the system command.\n   * It should be faster accrording to some person but I have not verified.\n   * At least, it is asynchrone.\n   *\n   * @param {type} dir : directory path\n   * @param {function} callback : (error, stdout, stderr)\n   */\n  rmDirRecursiveAsync: function (dir, callback) {\n    exec('rm -rf ' + dir, callback);\n  },\n\n  /**\n   * Get value of an object securely\n   *\n   * @param  {Object} rootObj object to read\n   * @param  {String} path    path rootObj.a.b.c\n   * @return {Mixed}          value\n   */\n  getValueOfPath: function (rootObj, path) {\n    if (typeof rootObj !== 'object' || typeof path !== 'string') {\n      return undefined;\n    }\n\n    var _currentObj = rootObj;\n\n    var _attrs = path.split('.');\n\n    for (var i = 0; i < _attrs.length; i++) {\n      var _attr = _attrs[i];\n\n      if (_currentObj[_attr] === undefined) {\n        debug('[[C_ERROR]] ' + _attr + ' not defined');\n        return '';\n      }\n\n      _currentObj = _currentObj[_attr];\n    }\n\n    return _currentObj;\n  },\n\n  /**\n   * Scan a directory and all sub-directory\n   * It does not return files and directories which start by a point. Example: .trash, .cache, .svn, ...\n   * This function is synchrone\n   *\n   * @param {string} dir : path to the directory we want to scan\n   * @param {string} extension (optional) : filter on file extension. Example: 'js' (without the point)\n   * @return {array} Array of files name with their path : ['/path/to/file1.js', '/path/to/file2.js']\n   */\n  walkDirSync: function (dir, extension) {\n    var _files = []; // if the path does not exist, return an empty table\n\n    if (!fs.existsSync(dir)) {\n      return _files;\n    } // eliminate all files which start by a point.\n\n\n    var _regExp = /^[^.]/;\n\n    if (extension instanceof RegExp) {\n      _regExp = extension;\n    } else if (extension) {\n      // we must use new RegExp because extension is variable\n      _regExp = new RegExp('^[^\\\\.].+\\\\.' + extension + '$');\n    }\n\n    walkDirRecursive(dir); // recursively called by himself until all sub-directories\n\n    function walkDirRecursive(dir) {\n      // read the directory\n      var _list = fs.readdirSync(dir);\n\n      for (var i = 0; i < _list.length; i++) {\n        var _filename = path.join(dir, _list[i]);\n\n        var _stat = fs.statSync(_filename);\n\n        var _baseName = path.basename(_filename); // get the base name in order to eliminate folder which starts by a point.\n\n\n        if (_stat.isFile() && _regExp.test(_baseName)) {\n          // if this is a file, push it in the table\n          _files.push(_filename);\n        } else if (_stat.isDirectory()) {\n          // if this is a directory, call the function recursively\n          walkDirRecursive(_filename);\n        }\n      }\n    }\n\n    return _files;\n  },\n\n  /**\n   * Copy an entire directory with all its content somewhere else\n   *\n   * @param {string} dirSource : directory source. Example /usr/lib/node\n   * @param {string} dirDest : directory destination. Example /usr\n   * In this example, it will copy the \"node\" directory or file in /usr/node\n   */\n  copyDirSync: function (dirSource, dirDest) {\n    var _sourceList = this.walkDirSync(dirSource);\n\n    var _parentSourceDir = path.dirname(dirSource); // replace the name of the files which contains {{=data.tableName}}\n\n\n    for (var i = 0; i < _sourceList.length; i++) {\n      // get the relative path\n      var _relativePath = path.relative(_parentSourceDir, _sourceList[i]); // re-positionned the sub directories to the destination directory\n\n\n      var _destPath = path.join(dirDest, _relativePath); // Get file info\n\n\n      var _stat = fs.statSync(_sourceList[i]);\n\n      if (_stat.isFile()) {\n        // if this is a file, copy its content\n        var _fileContent = fs.readFileSync(_sourceList[i], 'utf8');\n\n        this.writeFileDirSync(dirDest, _destPath, _fileContent);\n      } else if (_stat.isDirectory()) {\n        this.writeFileDirSync(dirDest, _destPath);\n      }\n    }\n  },\n\n  /**\n   * Write a file and create directory if they does not exist (NOT TESTED DIRECTLY)\n   *\n   * @param {string} root : Root where to stop searching for directory creation\n   * @param {string} fileOrDirPath : file or directory to write with an absolute path\n   * @param {string} content : content of the file\n   */\n  writeFileDirSync: function (root, fileOrDirPath, content) {\n    var _lastDirname = fileOrDirPath;\n    var _dirToCreate = [];\n\n    while (_lastDirname !== '/' && _lastDirname !== root) {\n      _lastDirname = path.dirname(_lastDirname);\n\n      if (!fs.existsSync(_lastDirname)) {\n        _dirToCreate.push(_lastDirname);\n      }\n    } // create directories\n\n\n    for (var i = _dirToCreate.length - 1; i >= 0; i--) {\n      fs.mkdirSync(_dirToCreate[i], '0755');\n    } // If the is a file, create it\n\n\n    if (typeof content !== 'undefined') {\n      fs.writeFileSync(fileOrDirPath, content);\n    }\n  },\n  replaceAll: function (str, find, replace) {\n    return str.replace(new RegExp(find.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&'), 'g'), replace);\n  },\n\n  /**\n   * Escape Regular expression characters\n   * @param  {String} str regular expression written as usual\n   * @return {String}     escape version\n   */\n  regexEscape: function (str) {\n    return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  },\n\n  /**\n   * Remove duplicated item of an already sorted array\n   * @param  {Array} sortedArrayToClean  array already SORTED\n   * @return {Array}                     new array without duplicated elements\n   */\n  removeDuplicatedRows: function (sortedArrayToClean) {\n    if (sortedArrayToClean.length === 0) {\n      return sortedArrayToClean;\n    }\n\n    var _previousItem = sortedArrayToClean[0];\n    var _arrayCleaned = [_previousItem];\n\n    for (var i = 1; i < sortedArrayToClean.length; i++) {\n      var _item = sortedArrayToClean[i];\n\n      if (_item !== _previousItem) {\n        _arrayCleaned.push(_item);\n\n        _previousItem = _item;\n      }\n    }\n\n    return _arrayCleaned;\n  },\n\n  /**\n   * find closest string\n   * @param  {String} str     string to search\n   * @param  {Array|Object}   choices array of string to search\n   * @return {String}         closest string from choices\n   */\n  findClosest: function (str, choices) {\n    var _choices = choices;\n\n    if (!(choices instanceof Array)) {\n      _choices = Object.keys(choices);\n    }\n\n    if (_choices.length === 0 || str === '') {\n      return '';\n    }\n\n    var _minDistance = str.length;\n    var _closest = 0;\n\n    for (var i = 0; i < _choices.length; i++) {\n      var _choice = _choices[i];\n\n      var _distance = helper.distance(str, _choice);\n\n      if (_distance < _minDistance) {\n        _minDistance = _distance;\n        _closest = i;\n      }\n    }\n\n    return _choices[_closest];\n  },\n\n  /**\n   * Compute distance between two string\n   * //https://github.com/awnist/distance\n   *\n   * @param  {String} s1 string to compare\n   * @param  {String} s2 string\n   * @return {Integer}   distance\n   */\n  distance: function (s1, s2) {\n    var c = 0;\n    var lcs = 0;\n    var offset1 = 0;\n    var offset2 = 0;\n    var i = 0;\n    var maxOffset = 5;\n\n    if (!(s1 !== null) || s1.length === 0) {\n      if (!(s2 !== null) || s2.length === 0) {\n        return 0;\n      } else {\n        return s2.length;\n      }\n    }\n\n    if (!(s2 !== null) || s2.length === 0) {\n      return s1.length;\n    }\n\n    while (c + offset1 < s1.length && c + offset2 < s2.length) {\n      if (s1[c + offset1] === s2[c + offset2]) {\n        lcs++;\n      } else {\n        offset1 = offset2 = i = 0;\n\n        while (i < maxOffset) {\n          if (c + i < s1.length && s1[c + i] === s2[c]) {\n            offset1 = i;\n            break;\n          }\n\n          if (c + i < s2.length && s1[c] === s2[c + i]) {\n            offset2 = i;\n            break;\n          }\n\n          i++;\n        }\n      }\n\n      c++;\n    }\n\n    return (s1.length + s2.length) / 2 - lcs;\n  }\n};\nmodule.exports = helper;","map":{"version":3,"sources":["/Users/doryan/Documents/Project/quoteCreator/node_modules/carbone/lib/helper.js"],"names":["fs","require","path","assert","crypto","params","exec","debug","sameUIDCounter","prevTimestamp","randomPool","Buffer","alloc","randomPoolPointer","length","helper","getUID","_timestamp","Date","now","_uid","uidPrefix","process","pid","RANDOM_STRING_LENGTH","getRandomString","randomFillSync","_randomStr","toString","slice","replace","encodeSafeFilename","str","from","decodeSafeFilename","filename","result","expected","message","equal","JSON","stringify","e","showDiff","readFileDirSync","dir","extension","_that","_res","_files","walkDirSync","i","_filePath","_code","readFileSync","cleanJavascriptVariable","attributeName","removeQuote","rmDirRecursive","existsSync","_list","readdirSync","_filename","join","_stat","statSync","isFile","unlinkSync","isDirectory","rmdirSync","rmDirRecursiveAsync","callback","getValueOfPath","rootObj","undefined","_currentObj","_attrs","split","_attr","_regExp","RegExp","walkDirRecursive","_baseName","basename","test","push","copyDirSync","dirSource","dirDest","_sourceList","_parentSourceDir","dirname","_relativePath","relative","_destPath","_fileContent","writeFileDirSync","root","fileOrDirPath","content","_lastDirname","_dirToCreate","mkdirSync","writeFileSync","replaceAll","find","regexEscape","removeDuplicatedRows","sortedArrayToClean","_previousItem","_arrayCleaned","_item","findClosest","choices","_choices","Array","Object","keys","_minDistance","_closest","_choice","_distance","distance","s1","s2","c","lcs","offset1","offset2","maxOffset","module","exports"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar assert = require('assert');\nvar crypto = require('crypto');\nvar params = require('./params');\nvar exec = require('child_process').exec;\nvar debug = require('debug')('carbone:helper');\n\nvar sameUIDCounter = 0;\nvar prevTimestamp = 0;\n\n// Random values to pre-allocate\nconst randomPool      = Buffer.alloc(256);\nvar randomPoolPointer = randomPool.length;\n\nvar helper = {\n\n  /**\n   * Generate a unique id\n   * @return {String} unique id\n   */\n  getUID : function () {\n    var _timestamp = Date.now();\n    var _uid = params.uidPrefix + '_' +_timestamp + '_' + process.pid + '_';\n    if (_timestamp === prevTimestamp) {\n      _uid += ++sameUIDCounter;\n    }\n    else {\n      _uid += '0';\n      sameUIDCounter = 0;\n    }\n    prevTimestamp = _timestamp;\n    return _uid;\n  },\n\n  /**\n   * Generate a constant-length base64 random string without forbidden characters for filesystem\n   *\n   * [/+] are replaced by [-_]\n   *\n   * Length : 22 characters\n   * It is 5 times slower than getUID above but a lot more secure to generate public filename\n   *\n   * It uses Cryptographically Secure Pseudo-Random Number Generator, with unbiased (ie secure) tranformation\n   * Same collision probability as standard 128 bits uuid-v4\n   * Doc: https://gist.github.com/joepie91/7105003c3b26e65efcea63f3db82dfba\n   *\n   * @return {String}   The random string\n   */\n  RANDOM_STRING_LENGTH : 22,\n  getRandomString      : function () {\n    if (randomPoolPointer > randomPool.length - 16) {\n      // It is alot simpler to use sync version\n      // Otherwose, we must maintain a table of callback\n      // This sync function is called 1/16 times\n      crypto.randomFillSync(randomPool);\n      randomPoolPointer = 0;\n    }\n    let _randomStr = randomPool.toString('base64', randomPoolPointer, (randomPoolPointer += 16));\n    return _randomStr.slice(0, -2).replace(/\\//g,'-').replace(/\\+/g,'_');\n  },\n\n\n  /**\n   * Encode any string to a base64 string, safe for generating POSIX compatible filenames\n   *\n   * @param  {String}  str The string\n   * @return {String}      A safe filename\n   */\n  encodeSafeFilename : function (str) {\n    return Buffer.from(str||'').toString('base64').replace(/=/g,'').replace(/\\//g,'-').replace(/\\+/g,'_');\n  },\n\n  /**\n   * Decode a base64 safe filename to the original string\n   *\n   * @param  {String}  filename  The filename\n   * @return {String}            Return original string\n   */\n  decodeSafeFilename : function (filename) {\n    return Buffer.from((filename||'').replace(/-/g,'/').replace(/_/g,'+'), 'base64').toString('utf8');\n  },\n\n  /**\n   * Beautiful assert between two objects\n   * Be careful, it will inspect with a depth of 100\n   *\n   * @param {object} result : result\n   * @param {object} expected : expected\n   * @return {type} throw an error if the two objects are different\n   */\n  assert : function (result, expected, message) {\n    try {\n      assert.equal(JSON.stringify(result, null, 2), JSON.stringify(expected, null, 2), message);\n    }\n    catch (e) {\n      e.showDiff = true;\n      throw e;\n    }\n  },\n  /**\n   * Read all files of a directory\n   *\n   * @param {string} dir : path to the directory we want to scan\n   * @param {string} extension (optional) : filter on file extension. Example: 'sql' (without the point). Can be a regex\n   * @return {object} : {'file/path/name.js':'content of the file', ...}\n   */\n  readFileDirSync : function (dir, extension) {\n    var _that = this;\n    var _res = {};\n    var _files = _that.walkDirSync(dir,extension);\n    for (var i = 0; i < _files.length; i++) {\n      var _filePath = _files[i];\n      var _code = fs.readFileSync(_filePath, 'utf8');\n      _res[_filePath] = _code;\n    }\n    return _res;\n  },\n\n  cleanJavascriptVariable : function (attributeName) {\n    return  attributeName.replace(/[^a-zA-Z0-9$_]/g, '_');\n  },\n\n  /**\n   * Remove quotes from string\n   *\n   * @param  {Strring} str  string with or without quotes\n   * @return {String}       string without surrounding quotes\n   */\n  removeQuote : function (str) {\n    if (typeof(str) === 'string') {\n      return str.replace(/^ *['\"]?/, '').replace(/['\"]? *$/, '');\n    }\n    return str;\n  },\n\n  /**\n   * Remove a directory and all its content\n   * Be careful, this method is synchrone\n   *\n   * @param {type} dir : directory path\n   */\n  rmDirRecursive : function (dir) {\n\n    if (!fs.existsSync(dir)) {\n      return;\n    }\n    var _list = fs.readdirSync(dir);\n\n    for (var i = 0; i < _list.length; i++) {\n      var _filename = path.join(dir, _list[i]);\n      var _stat = fs.statSync(_filename);\n\n      if (_stat.isFile()) {\n        // if this is a file, remove it\n        fs.unlinkSync(_filename);\n      }\n      else if (_stat.isDirectory()) {\n        // if the is a dircetory, call the function recursively\n        this.rmDirRecursive(_filename);\n      }\n    }\n    fs.rmdirSync(dir);\n  },\n\n  /**\n   * Remove a directory and all its content using the system command.\n   * It should be faster accrording to some person but I have not verified.\n   * At least, it is asynchrone.\n   *\n   * @param {type} dir : directory path\n   * @param {function} callback : (error, stdout, stderr)\n   */\n  rmDirRecursiveAsync : function (dir, callback) {\n    exec('rm -rf '+dir, callback);\n  },\n\n  /**\n   * Get value of an object securely\n   *\n   * @param  {Object} rootObj object to read\n   * @param  {String} path    path rootObj.a.b.c\n   * @return {Mixed}          value\n   */\n  getValueOfPath : function (rootObj, path) {\n    if (typeof(rootObj) !== 'object' || typeof(path) !== 'string') {\n      return undefined;\n    }\n    var _currentObj = rootObj;\n    var _attrs = path.split('.');\n    for (var i = 0; i < _attrs.length; i++) {\n      var _attr = _attrs[i];\n      if (_currentObj[_attr] === undefined) {\n        debug('[[C_ERROR]] '+_attr+' not defined');\n        return '';\n      }\n      _currentObj = _currentObj[_attr];\n    }\n    return _currentObj;\n  },\n\n  /**\n   * Scan a directory and all sub-directory\n   * It does not return files and directories which start by a point. Example: .trash, .cache, .svn, ...\n   * This function is synchrone\n   *\n   * @param {string} dir : path to the directory we want to scan\n   * @param {string} extension (optional) : filter on file extension. Example: 'js' (without the point)\n   * @return {array} Array of files name with their path : ['/path/to/file1.js', '/path/to/file2.js']\n   */\n  walkDirSync : function (dir, extension) {\n    var _files = [];\n\n    // if the path does not exist, return an empty table\n    if (!fs.existsSync(dir)) {\n      return _files;\n    }\n\n    // eliminate all files which start by a point.\n    var _regExp = /^[^.]/;\n\n    if (extension instanceof RegExp) {\n      _regExp = extension;\n    }\n    else if (extension) {\n      // we must use new RegExp because extension is variable\n      _regExp = new RegExp('^[^\\\\.].+\\\\.'+extension+'$');\n    }\n\n    walkDirRecursive(dir);\n    // recursively called by himself until all sub-directories\n    function walkDirRecursive (dir) {\n      // read the directory\n      var _list = fs.readdirSync(dir);\n\n      for (var i = 0; i < _list.length; i++) {\n        var _filename = path.join(dir, _list[i]);\n        var _stat = fs.statSync(_filename);\n        var _baseName = path.basename(_filename); // get the base name in order to eliminate folder which starts by a point.\n\n        if (_stat.isFile() && _regExp.test(_baseName)) {\n          // if this is a file, push it in the table\n          _files.push(_filename);\n        }\n        else if (_stat.isDirectory()) {\n          // if this is a directory, call the function recursively\n          walkDirRecursive(_filename);\n        }\n      }\n    }\n    return _files;\n  },\n\n\n  /**\n   * Copy an entire directory with all its content somewhere else\n   *\n   * @param {string} dirSource : directory source. Example /usr/lib/node\n   * @param {string} dirDest : directory destination. Example /usr\n   * In this example, it will copy the \"node\" directory or file in /usr/node\n   */\n  copyDirSync : function (dirSource, dirDest) {\n\n    var _sourceList = this.walkDirSync(dirSource);\n    var _parentSourceDir = path.dirname(dirSource);\n\n    // replace the name of the files which contains {{=data.tableName}}\n    for (var i = 0; i < _sourceList.length; i++) {\n      // get the relative path\n      var _relativePath = path.relative(_parentSourceDir, _sourceList[i]);\n      // re-positionned the sub directories to the destination directory\n      var _destPath = path.join(dirDest, _relativePath);\n      // Get file info\n      var _stat = fs.statSync(_sourceList[i]);\n\n      if (_stat.isFile()) {\n        // if this is a file, copy its content\n        var _fileContent = fs.readFileSync(_sourceList[i], 'utf8');\n        this.writeFileDirSync(dirDest, _destPath, _fileContent);\n      }\n      else if (_stat.isDirectory()) {\n        this.writeFileDirSync(dirDest, _destPath);\n      }\n    }\n  },\n\n\n  /**\n   * Write a file and create directory if they does not exist (NOT TESTED DIRECTLY)\n   *\n   * @param {string} root : Root where to stop searching for directory creation\n   * @param {string} fileOrDirPath : file or directory to write with an absolute path\n   * @param {string} content : content of the file\n   */\n  writeFileDirSync : function (root, fileOrDirPath, content) {\n    var _lastDirname = fileOrDirPath;\n    var _dirToCreate = [];\n\n    while (_lastDirname!=='/' && _lastDirname!==root) {\n      _lastDirname = path.dirname(_lastDirname);\n      if (!fs.existsSync(_lastDirname)) {\n        _dirToCreate.push(_lastDirname);\n      }\n    }\n    // create directories\n    for (var i = _dirToCreate.length-1; i >= 0; i--) {\n      fs.mkdirSync(_dirToCreate[i], '0755');\n    }\n    // If the is a file, create it\n    if (typeof (content) !== 'undefined') {\n      fs.writeFileSync(fileOrDirPath, content);\n    }\n  },\n\n  replaceAll : function (str, find, replace) {\n    return str.replace(new RegExp(find.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&'), 'g'), replace);\n  },\n\n  /**\n   * Escape Regular expression characters\n   * @param  {String} str regular expression written as usual\n   * @return {String}     escape version\n   */\n  regexEscape : function (str) {\n    return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  },\n\n  /**\n   * Remove duplicated item of an already sorted array\n   * @param  {Array} sortedArrayToClean  array already SORTED\n   * @return {Array}                     new array without duplicated elements\n   */\n  removeDuplicatedRows : function (sortedArrayToClean) {\n    if (sortedArrayToClean.length === 0) {\n      return sortedArrayToClean;\n    }\n    var _previousItem = sortedArrayToClean[0];\n    var _arrayCleaned = [_previousItem];\n    for (var i = 1; i < sortedArrayToClean.length; i++) {\n      var _item = sortedArrayToClean[i];\n      if (_item !== _previousItem) {\n        _arrayCleaned.push(_item);\n        _previousItem = _item;\n      }\n    }\n    return _arrayCleaned;\n  },\n\n  /**\n   * find closest string\n   * @param  {String} str     string to search\n   * @param  {Array|Object}   choices array of string to search\n   * @return {String}         closest string from choices\n   */\n  findClosest : function (str, choices) {\n    var _choices = choices;\n    if ( !(choices instanceof Array) ) {\n      _choices = Object.keys(choices);\n    }\n    if (_choices.length === 0 || str === '') {\n      return '';\n    }\n    var _minDistance = str.length;\n    var _closest = 0;\n    for (var i = 0; i < _choices.length; i++) {\n      var _choice = _choices[i];\n      var _distance = helper.distance(str, _choice);\n      if (_distance < _minDistance) {\n        _minDistance = _distance;\n        _closest = i;\n      }\n    }\n    return _choices[_closest];\n  },\n\n  /**\n   * Compute distance between two string\n   * //https://github.com/awnist/distance\n   *\n   * @param  {String} s1 string to compare\n   * @param  {String} s2 string\n   * @return {Integer}   distance\n   */\n  distance : function (s1, s2) {\n    var c = 0;\n    var lcs = 0;\n    var offset1 = 0;\n    var offset2 = 0;\n    var i = 0;\n    var maxOffset = 5;\n    if (!(s1 !== null) || s1.length === 0) {\n      if (!(s2 !== null) || s2.length === 0) {\n        return 0;\n      }\n      else {\n        return s2.length;\n      }\n    }\n    if (!(s2 !== null) || s2.length === 0) {\n      return s1.length;\n    }\n    while ((c + offset1 < s1.length) && (c + offset2 < s2.length)) {\n      if (s1[c + offset1] === s2[c + offset2]) {\n        lcs++;\n      }\n      else {\n        offset1 = offset2 = i = 0;\n        while (i < maxOffset) {\n          if ((c + i < s1.length) && (s1[c + i] === s2[c])) {\n            offset1 = i;\n            break;\n          }\n          if ((c + i < s2.length) && (s1[c] === s2[c + i])) {\n            offset2 = i;\n            break;\n          }\n          i++;\n        }\n      }\n      c++;\n    }\n    return (s1.length + s2.length) / 2 - lcs;\n  }\n\n};\n\nmodule.exports = helper;"]},"metadata":{},"sourceType":"script"}